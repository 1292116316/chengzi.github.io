一:
哈希表中关键码就是数组的索引下标，然后通过下标直接访问数组中的元素。
一般哈希表都是用来快速判断一个元素是否出现集合里。
两元素都映射到了相同索引下标的位置，这一现象叫做哈希碰撞。
一般哈希碰撞有两种解决方法， 拉链法和线性探测法。
（1）其实拉链法就是要选择适当的哈希表的大小，这样既不会因为数组空值而浪费大量内存，也不会因为链表太长而在查找上浪费太多时间。
（2）使用线性探测法，一定要保证tableSize大于dataSize。 我们需要依靠哈希表中的空位来解决碰撞问题。
二:
常见的三种哈希结构
数组
set （集合）
map(映射)
| 集合 | 底层实现 | 是否有序 | 数值是否可以重复 | 能否更改数值 | 查询效率 | 增删效率 | 
| std::set | 红黑树 | 有序 | 否 | 否 | O(log n) | O(log n) | 
| std::multiset | 红黑树 | 有序 | 是 | 否 | O(logn) | O(logn) | 
| std::unordered_set | 哈希表 | 无序 | 否 | 否 | O(1) | O(1) |

std::unordered_set底层实现为哈希表，std::set 和std::multiset 的底层实现是红黑树，红黑树是一种平衡二叉搜索树，所以key值是有序的，
但key不可以修改，改动key值会导致整棵树的错乱，所以只能删除和增加。

| 映射 | 底层实现 | 是否有序 | 数值是否可以重复 | 能否更改数值 | 查询效率 | 增删效率 |
| std::map | 红黑树 | key有序 | key不可重复 | key不可修改 | O(logn) | O(logn) | 
| std::multimap | 红黑树 | key有序 | key可重复 | key不可修改 | O(log n) | O(log n) | 
| std::unordered_map | 哈希表 | key无序 | key不可重复 | key不可修改 | O(1) | O(1) |

std::unordered_map 底层实现为哈希表，std::map 和std::multimap 的底层实现是红黑树。
同理，std::map 和std::multimap 的key也是有序的（这个问题也经常作为面试题，考察对语言容器底层的理解）。
当我们要使用集合来解决哈希问题的时候，优先使用unordered_set，因为它的查询和增删效率是最优的，
如果需要集合是有序的，那么就用set，如果要求不仅有序还要有重复数据的话，那么就用multiset。

三：
总结一下，当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法。
但是哈希法也是牺牲了空间换取了时间，因为我们要使用额外的数组，set或者是map来存放数据，才能实现快速的查找。
