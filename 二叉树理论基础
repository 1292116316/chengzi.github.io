一.
  二叉树有两种主要的形式：满二叉树和完全二叉树。
二.
    满二叉树：
        如果一棵二叉树只有度为0的结点和度为2的结点，并且度为0的结点在同一层上，则这棵二叉树为满二叉树。
        二叉树为满二叉树，也可以说深度为k，有2^k-1个节点的二叉树。
    完全二叉树：
        在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。
        若最底层为第 h 层，则该层包含 1~ 2^(h-1) 个节点。
        之前我们刚刚讲过优先级队列其实是一个堆，堆就是一棵完全二叉树，同时保证父子节点的顺序关系。
    二叉搜索树：
        二叉搜索树是有数值的了，二叉搜索树是一个有序树。
        1.若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；
        2.若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；
       3.它的左、右子树也分别为二叉排序树
    平衡二叉搜索树：
        又被称为AVL（Adelson-Velsky and Landis）树，且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。
        C++中map、set、multimap，multiset的底层实现都是平衡二叉搜索树，所以map、set的增删操作时间时间复杂度是logn，
        注意我这里没有说unordered_map、unordered_set，unordered_map、unordered_set底层实现是哈希表。、
        二叉树的存储方式：
        二叉树可以链式存储，也可以顺序存储。
        那么链式存储方式就用指针，顺序存储的方式就是用数组。顾名思义就是顺序存储的元素在内存是连续分布的，而链式存储则是通过指针把分布在各个地址的节点串联一起。
    二叉树的遍历方式：
        1.深度优先遍历：先往深走，遇到叶子节点再往回走。
        2.广度优先遍历：一层一层的去遍历。
    深度优先遍历
        前序遍历（递归法，迭代法）
        中序遍历（递归法，迭代法）
        后序遍历（递归法，迭代法）
    广度优先遍历
        层次遍历（迭代法）
    在深度优先遍历中：有三个顺序，前中后序遍历， 有同学总分不清这三个顺序，经常搞混，我这里教大家一个技巧。
    这里前中后，其实指的就是中间节点的遍历顺序，只要大家记住前中后序指的就是中间节点的位置就可以了。
    前序遍历：中左右
    中序遍历：左中右
    后序遍历：左右中
    之前我们讲栈与队列的时候，就说过栈其实就是递归的一种实现结构，也就说前中后序遍历的逻辑其实都是可以借助栈使用非递归的方式来实现的。
    而广度优先遍历的实现一般使用队列来实现，这也是队列先进先出的特点所决定的，因为需要先进先出的结构，才能一层一层的来遍历二叉树。
三.
    二叉树的定义：
    (c++)
    struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
    };
    (java)
    public class TreeNode {
    int val;
  	TreeNode left;
  	TreeNode right;
  	TreeNode() {}
  	TreeNode(int val) { this.val = val; }
  	TreeNode(int val, TreeNode left, TreeNode right) {
    		this.val = val;
    		this.left = left;
    		this.right = right;
  	}
    }
    
    
    
    
    
    
